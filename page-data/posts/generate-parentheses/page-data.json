{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/posts/generate-parentheses",
    "result": {"data":{"markdownRemark":{"html":"<p>Given <code class=\"language-text\">n</code>, write a function to generate all combinations of well-formed parentheses. This problem can be solved in <a href=\"https://leetcode.com/problems/generate-parentheses/description/\">LeetCode</a>.</p>\n<h2>Examples<a id=\"sec-1-1\"></a></h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">n = 1\n[\"()\"]\n\nn = 2\n[\"(())\", \"()()\"]\n\nn = 3\n[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]</code></pre></div>\n<h2>Solution<a id=\"sec-1-2\"></a></h2>\n<p>If the problem is to find the number of the combination, this is a Catalan number sequence problem. However, we need to print all combinations. Therefore, this is a typical backtracking search problem because we need to explore every possible outcomes.</p>\n<p>Let's look at the code first.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">generate_parenthesis</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"Generate all combinations of well-formed parentheses\n\n    Example:\n        >>> generate_parenthesis(3)\n        ['((()))', '(()())', '(())()', '()(())', '()()()']\n    \"\"\"</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">backtrack</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span>\n                  left<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span>\n                  right<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span>\n                  result<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> n<span class=\"token punctuation\">:</span>\n            result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> left <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">:</span>\n            backtrack<span class=\"token punctuation\">(</span>current <span class=\"token operator\">+</span> <span class=\"token string\">\"(\"</span><span class=\"token punctuation\">,</span> left <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> right <span class=\"token operator\">&lt;</span> left<span class=\"token punctuation\">:</span>\n            backtrack<span class=\"token punctuation\">(</span>current <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> result\n\n    <span class=\"token keyword\">return</span> backtrack<span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>One way of tackling this problem is to track the number of open(left) parentheses and the number of close(right) parentheses.</p>\n<p>Suppose</p>\n<ul>\n<li><strong><code class=\"language-text\">left</code>:</strong> the number of open parentheses</li>\n<li><strong><code class=\"language-text\">right</code>:</strong> the number of close parentheses</li>\n</ul>\n<p>Then,</p>\n<ul>\n<li>We know we can have <code class=\"language-text\">n</code> open parentheses and <code class=\"language-text\">n</code> close parentheses</li>\n<li>Therefore, add a open parenthesis as long as <code class=\"language-text\">left &lt; n</code>.</li>\n<li>We can only add a closing parenthesis when <code class=\"language-text\">right &lt; left</code>.</li>\n</ul>\n<p>Notice that we don't break the validity of the parentheses as long as we close parentheses when <code class=\"language-text\">right &lt; left</code>.</p>","excerpt":"Given , write a function to generate all combinations of well-formed parentheses. This problem can be solved in LeetCode. Examples Solutionâ€¦","frontmatter":{"date":"March 15, 2018","title":"Generate parentheses","keywords":"python, backtracking","description":null},"fields":{"slug":"posts/generate-parentheses"}}},"pageContext":{"slug":"posts/generate-parentheses"}},
    "staticQueryHashes": []}